# ModelGenerator Family ---------------------------------------------------

#' @name CALC.ModelGenerator
#' @description Creates a dataframe of all possible linear regressions with each permutation of model and accession.
#' @param data_df A dataframe containing all measured data points with IDs and their measures.
#' @param models_df A dataframe containing the model strings for all models of interest.
#' @returns A dataframe containing every linear model in \code{models_df}, generated for each accession in \code{SWITCHBOARD.ACCESSIONLIST}
#' @example CALC.ModelGenerator(SWITCHBOARD.csvMAINFILE, SWITCHBOARD.MODELS_DF)

CALC.ModelGenerator <- function(data_df, fill_models_df) {
  
  fits_frame <- data.frame(accession = SWITCHBOARD.ACCESSIONLIST)
  for(model in fill_models_df$models) {
    new_models <- data_df %>%
      group_by(accession) %>%
      do(model = lm(model, data = .)) %>%
      setNames(c("accession", model)) %>%
      column_to_rownames("accession")
    fits_frame <- cbind(fits_frame, new_models[model])
  }
  return(fits_frame)
}

#' @name CALC.ModelGenerator_AllAccession_R2
#' @description Creates a list of adj. R^2 values over the entire dataset, not just specific accessions.
#' @param data_df A dataframe containing all measured data points with IDs and their measures.
#' @param fill_models_df A vector of model strings.
#' @returns A named list of adj. R^2 values as doubles.

CALC.ModelGenerator_AllAccessions_R2 <- function(data_df, fill_models_df) {
  list_out <- list()
  for(model in fill_models_df$models) {
    list_out <- list_out %>%
      append(summary(lm(model, data = data_df))[["adj.r.squared"]])
  }
  names(list_out) <- fill_models_df$models
  return(list_out)
}

#' @name CALC.ModelGenerator_AllAccessions_SBC
#' @description Creates a list of SBC values over the entire dataset, not just specific accessions.
#' @param data_df A dataframe containing all measured data points with IDs and their measures.
#' @param fill_models_df A vector of model strings.
#' @example A named list of SBC values as doubles.

CALC.ModelGenerator_AllAccessions_SBC <- function(data_df, fill_models_df) {
  list_out <- list()
  for(model in fill_models_df$models) {
    list_out <- list_out %>%
      append(BIC(lm(model, data = data_df)))
  }
  names(list_out) <- fill_models_df$models
  return(list_out)
}


# Tukey Test Family -------------------------------------------------------

#' @name CALC.tukeyTester
#' @description Returns Tukey Test data on confidence intervals between accessions for a single measure.
#' @param data_df A source datafile containing cactus pad IDs and their corresponding measures.
#' @param measure The specific measure to test over all accessions.
#' @returns Tukey confidence interval dataframe of higher and lower interval endpoints for each comparison requested.
#' names = factor, diff, lwr, upr, p adj
#' @example CALC.tukeyTester(SWITCHBOARD.csvMAINFILE, "height")

CALC.tukeyTester <- function(data_df, measure) {
  
  model=lm(data_df[[measure]] ~ factor(data_df$accession))
  ANOVA=aov(model)
  tukey_results <- TukeyHSD(x=ANOVA, 'factor(data_df$accession)', conf.level=0.95)
  return(tukey_results)
}

#' @name CALC.tukeyLabel_DF
#' @description Labels accessions by groups that aren't significantly different (using data from CALC.tukeyTester)
#' @param tukey_results A list of intervals generated by CALC.tukeyTester.
#' @returns A dataframe with two columns: a Letters column containing the letters designating the groups that the accessions belong to, and the accession column.

CALC.tukeyLabel_DF <- function(tukey_results) {
  Tukey.levels <- tukey_results[["factor(data_df$accession)"]][,4]
  Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
  Tukey.labels$accession=rownames(Tukey.labels)
  rownames(Tukey.labels) <- NULL
  Tukey.labels=Tukey.labels[order(Tukey.labels$accession), ]
  return(Tukey.labels)
}

#' @name CALC.tukeyRelation
#' @description Breaks down a group relation dataframe generated by CALC.tukeyTester into individual hypernode membership datapoints.
#' @param tukey_labels A two-column dataframe generated by CALC.tukeyTester
#' @returns A two-column dataframe - the first contains a single letter (group designation), and the second column contains a single accession.

CALC.tukeyRelation <- function(tukey_labels) {
  tukey_relation <- tukey_labels
  tukey_relation$Letters <- sapply(tukey_relation$Letters, strsplit, split = "")
  tukey_relation <- separate_rows(tukey_relation, Letters)
  tukey_relation <- tukey_relation[which(tukey_relation$Letters != ""),]
  return(tukey_relation)
}

#' @name CALC.tukeyEdgelist
#' @description Splits a edgelist dataframe into a vector of groups and the accessions they contain, in a format that can be used to generate a hypergraph.
#' @param tukey_relation A relation dataframe returned by CALC.tukeyRelation
#' @returns A named vector of groups (as letters) with collections of member accessions as values.

CALC.tukeyEdgelist <- function(tukey_relation) {
  tukey_edgelist <- split(tukey_relation$accession, tukey_relation$Letters)
  return(tukey_edgelist)
}


# Model Acquisition and Filtration ----------------------------------------

#' @name CALC.ModelFetch
#' @description 
#' Retrieves a model from a dataframe constructed by a ModelGenerator() call, using the accession and model_name passed.
#'   Will throw an error to the console if the requested model is not present in the dataset.
#'   Will throw an error if the requested accession is not present in the dataset.
#' 
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @param accession An integer corresponding to an accession from the database.
#' @param model_name A string containing the model of interest to be retrieved.
#' @example CALC.ModelFetch(DATA_OBJECTS.LinearRegressions_DF, 242, "fresh_weight~width")

CALC.ModelFetch <- function(fits_df, accession, model_name) {
  if (!(model_name %in% colnames(fits_df)[-1])) {
    cat(paste0("The model '", model_name, "' is not present in ", deparse(substitute(fits_df)), "\n"))
    cat(paste0("Available models include: ", colnames(fits_df)[-1], "\n"))
    return(NULL)
  }
  if (!(accession %in% fits_df$accession)) {
    cat("Invalid Accession Number: ", accession, "\n")
    return(NULL)
  }
  return(fits_df[[model_name]][which(SWITCHBOARD.ACCESSIONLIST == accession)][[1]])
}

#' @name CALC.ModelNumHighLeverage
#' @description Given a linear model, returns the number data points whose leverage value exceeds a 3p/n threshold,
#'   where p is the number of parameters in the model, 
#'   and n is the number of data points in the model.
#' @param model_in A linear model object.

CALC.ModelNumHighLeverage <- function(model_in) {
  threshold = 3*length(model_in$coefficients)/length(model_in$model[[1]])
  return(length(which(hatvalues(model_in) > threshold)))
}

#' @name CALC.ModelIndexHighLeverage
#' @description Given a linear model, returns a vector of indices of data points whose leverage value exceeds a 3p/n threshold,
#'   where p is the number of parameters in the model, 
#'   and n is the number of data points in the model.
#' @param model_in A linear model object.

CALC.ModelIndexHighLeverage <- function(model_in) {
  threshold <- 3*length(model_in$coefficients)/length(model_in$model[[1]])
  result_index <- as.vector(which(hatvalues(model_in) > threshold))
  return(result_index)
}

#' @name CALC.ModelValuePairsFromIndex
#' @description Given an index and a linear model object, retrieves the values of the independent and dependent variable
#' @param result_index An integer corresponding to a datapoint in the model object.
#' @param model_in A linear model object with a single predictor variable and a single dependent variable.

CALC.ModelValuePairsFromIndex <- function(result_index, model_in) {
  if (length(result_index) == 0) {
    return(NULL)
  }
  model_data <- model_in$model
  cols <- names(model_data)
  return_values_df <- data.frame(matrix(ncol = 2, nrow = length(result_index)))
  colnames(return_values_df) <- cols
  
  for (loc in length(result_index)) {
    pass_1 <- model_data[result_index[loc],][cols[1]]
    pass_2 <- model_data[result_index[loc],][cols[2]]
    row <- c(pass_1, pass_2)
    return_values_df[loc,] <- row
  }
  
  if (nrow(return_values_df) != 0) {
    return(return_values_df)
  } else {
    return(NULL)
  }
}

#' @name CALC.PadIDfromModelValuePairs
#' @description Given a dataframe of corresponding value pairs, a source dataframe, and an accession number, assigns 
#' @param value_pairs_df Value pair columns extracted from a linear model object.
#' @param data_df A source datafile containing cactus pad IDs and their corresponding measures.
#' @param accession An integer corresponding to an accession from the database.

CALC.PadIDfromModelValuePairs <- function(value_pairs_df, data_df, accession) {
  #print(length(nrow(value_pairs_df)))
  #print(value_pairs_df)
  if(nrow(value_pairs_df) == 0) {
    return(NULL)
  }
  pad_id_vec <- c()
  field_1 <- names(value_pairs_df)[1]
  field_2 <- names(value_pairs_df)[2]
  for(row in c(1:nrow(value_pairs_df))) {
    add_id <- data_df[
      which(
        data_df[[field_1]] == value_pairs_df[[field_1]][row] & 
          data_df[[field_2]] == value_pairs_df[[field_2]][row] & 
          data_df$accession == accession),
    ]$completeID
    pad_id_vec <- c(pad_id_vec, add_id)
  }
  #print(pad_id_vec)
  return(pad_id_vec)
}


# Summary Statistic Calculation -------------------------------------------

#' @name CALC.df_SBC
#' @description Generates a dataframe of Schwarz-Bayes Criterion values from a dataframe of linear models. Each SBC value corresponds to the model in the position it occupied.
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @example CALC.df_SBC(DATA_OBJECTS.LinearRegressions_DF)

CALC.df_SBC <- function(fits_df) {
  return_df <- fits_df
  for (col in 2:ncol(fits_df)) {
    for (row in 1:nrow(fits_df)) {
      return_df[row, col] <- BIC(return_df[row, col][[1]])[[1]]
      #print(class(return_df[row, col]))
      #cat(ifelse(class(return_df[row, col]) == "list", "!", "&"))
    }
    return_df[,col] <- unlist(return_df[,col])
  }
  return(return_df)
}

#' @name CALC.df_R2
#' @description Generates a dataframe of Adjusted R^2 values from a dataframe of linear models. Each Adj. R^2 value corresponds to the model in the position it occupied.
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @example CALC.df_R2(DATA_OBJECTS.LinearRegressions_DF)

CALC.df_R2 <- function(fits_df) {
  return_df <- fits_df
  for (col in 2:ncol(fits_df)) {
    for (row in 1:nrow(fits_df)) {
      return_df[row, col] <- summary(return_df[row, col][[1]])[["adj.r.squared"]]
      #print(class(return_df[row, col]))
      #cat(ifelse(class(return_df[row, col]) == "list", "#", "@"))
    }
    return_df[,col] <- unlist(return_df[,col])
  }
  return(return_df)
}


# Result Comparison Functions ---------------------------------------------
# These functions do things slightly differently from previously defined functions, so they take previously defined environment variables and do not take any parameters.


#' @name CALC.CompareREIS_FRESHWEIGHT
#' @description Compares Reis et. al.'s regression for Cladode Fresh weight on their data with the same formula type on the current data,
#' as well as the full multiplicative and elliptical models for fresh weight created in this analysis.

CALC.CompareREIS_FRESHWEIGHT <- function() {
  DATA_OBJECTS.Comparison.REIS.freshweight <- data.frame(matrix(0.91, ncol = 1, nrow = 15)) %>%
    mutate(a = DATA_OBJECTS.comparison_mult_R2_FILT$`fresh_weight~width*height*thickness`) %>%
    mutate(b = DATA_OBJECTS.comparison_mult_R2_FILT$`fresh_weight~width*height*diameter*thickness`) %>%
    mutate(c = DATA_OBJECTS.comparison_ellip_R2_FILT$`fresh_weight~Theo_Area*thickness*Pade_Derived_Diam`) %>%
    `rownames<-`(c(SWITCHBOARD.ACCESSIONLIST, "All")) %>%
    `colnames<-`(c("Reis L*W*T", "L*W*T", "L*W*T*D", "Full Ellip.")) %>%
    rownames_to_column("accession") %>%
    select(c(1, 3, 4, 5, 2)) %>%
    `rownames<-`(c(SWITCHBOARD.ACCESSIONLIST, "All"))
  
  UTIL.quickPNG("Reis-et-al FW Compare", "Heatmaps\\Graphs")
  
  heatmap_plot <- DATA_OBJECTS.Comparison.REIS.freshweight %>% pivot_longer(cols = -1, names_to = "models", values_to = "values") %>%
    mutate(models = factor(models, levels = colnames(DATA_OBJECTS.Comparison.REIS.freshweight))) %>%
    ggplot(aes(as.factor(models), as.factor(accession), fill = values)) +
    geom_tile() +
    xlab("Models") +
    ylab("Accession") +
    ggtitle("Reis-et-al FW Compare") +
    theme(axis.text.x = element_text(angle = 60, vjust = 0, hjust=0)) +
    scale_fill_viridis(direction = -1, begin = max(DATA_OBJECTS.Comparison.REIS.freshweight[-1]), end = ifelse(min(DATA_OBJECTS.Comparison.REIS.freshweight[-1]) < 0, 0, min(DATA_OBJECTS.Comparison.REIS.freshweight[-1])))
  print(heatmap_plot)
  
  dev.off()
  
  UTIL.quickCSV(DATA_OBJECTS.Comparison.REIS.freshweight, "Reis-et-al FW Compare", "Heatmaps\\Tables")
}

#' @name CALC.CompareREIS_AREA
#' @description Compares Reis et. al.'s regression for cladode area on their data with the same formula type on the current data,
#' as well as the elliptical approximation and diameter-augmented approximation (A_th*D) on the current data.

CALC.CompareREIS_AREA <- function() {
  
  DATA_OBJECTS.Comparison.REIS.area <- DATA_OBJECTS.ComparativeRegressions_REIS_AREA_UNFILT %>%
    CALC.df_R2() %>%
    UTIL.AllAccessionToMain(CALC.ModelGenerator_AllAccessions_R2(SWITCHBOARD.csvAUGMFILE, DATA_OBJECTS.Comparison.REIS.area)) %>%
    `colnames<-`(c("accession", SWITCHBOARD.models_to_compare.REIS.AREA_abbr)) %>%
    mutate("Reis Area" = 0.91)
  
  UTIL.quickPNG("Reis-et-al Area Compare", "Heatmaps\\Graphs")
  
  heatmap_plot <- DATA_OBJECTS.Comparison.REIS.area %>% pivot_longer(cols = -1, names_to = "models", values_to = "values") %>%
    mutate(models = factor(models, levels = colnames(DATA_OBJECTS.Comparison.REIS.area))) %>%
    ggplot(aes(as.factor(models), as.factor(accession), fill = values)) +
    geom_tile() +
    xlab("Models") +
    ylab("Accession") +
    ggtitle("Reis-et-al Area Compare") +
    theme(axis.text.x = element_text(angle = 60, vjust = 0, hjust=0)) +
    scale_fill_viridis(direction = -1, begin = max(DATA_OBJECTS.Comparison.REIS.area[-1]), end = ifelse(min(DATA_OBJECTS.Comparison.REIS.area[-1]) < 0, 0, min(DATA_OBJECTS.Comparison.REIS.area[-1])))
  print(heatmap_plot)
  
  dev.off()
  
  UTIL.quickCSV(DATA_OBJECTS.Comparison.REIS.area, "Reis-et-al Area Compare", "Heatmaps\\Tables")
}

#' @name CALC.CompareREIS_DRYWEIGHT
#' @description 
CALC.CompareREIS_DRYWEIGHT <- function() {
  DATA_OBJECTS.Comparison.REIS.dryweight <- DATA_OBJECTS.ComparativeRegressions_REIS_DRYWEIGHT_UNFILT %>%
    CALC.df_R2() %>%
    UTIL.AllAccessionToMain(CALC.ModelGenerator_AllAccessions_R2(SWITCHBOARD.csvAUGMFILE, DATA_OBJECTS.Comparison.REIS.dryweight)) %>%
    `colnames<-`(c("accession", SWITCHBOARD.models_to_compare.REIS.DRYWEIGHT_abbr)) %>%
    mutate("Reis DW" = 0.72) 
  
  UTIL.quickPNG("Reis-et-al Dry Weight Compare", "Heatmaps\\Graphs")
  
  heatmap_plot <- DATA_OBJECTS.Comparison.REIS.dryweight %>% pivot_longer(cols = -1, names_to = "models", values_to = "values") %>%
    mutate(models = factor(models, levels = colnames(DATA_OBJECTS.Comparison.REIS.dryweight))) %>%
    ggplot(aes(as.factor(models), as.factor(accession), fill = values)) +
    geom_tile() +
    xlab("Models") +
    ylab("Accession") +
    ggtitle("Reis-et-al Dry Weight Compare") +
    theme(axis.text.x = element_text(angle = 60, vjust = 0, hjust=0)) +
    scale_fill_viridis(direction = -1, begin = max(DATA_OBJECTS.Comparison.REIS.dryweight[-1]), end = ifelse(min(DATA_OBJECTS.Comparison.REIS.dryweight[-1]) < 0, 0, min(DATA_OBJECTS.Comparison.REIS.dryweight[-1])))
  print(heatmap_plot)
  
  dev.off()
  
  UTIL.quickCSV(DATA_OBJECTS.Comparison.REIS.dryweight, "Reis-et-al Dry Weight Compare", "Heatmaps\\Tables")
}

