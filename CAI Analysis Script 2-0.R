# This program was written to automate on a large scale the statistical analyses
# done in R, in order to save time - so that minor changes to analytical processes
# may be quickly reflected across the entire analysis. This allows hours of work
# to be repeated, with or without changes, in less than two minutes while analyzing 
# thousands of datapoints.
#
# The program is interspersed with diagnostic output messages ("cat(...)") that 
# output to the console and indicate the progression of the program.
# 
# Contact gangres@nevada.unr.edu for questions regarding the code's function and 
# behavior.

 

#Establish working directory with target files.

cat("Setting Working Directory...\n")
setwd("C:\\Users\\gjang\\Documents\\GitHub\\CAI-Analysis-Script")

SWITCHBOARD.DIRECTORY <-
  "C:\\Users\\gjang\\Documents\\GitHub\\CAI-Analysis-Script\\Script-v2"

#Load relevant packages into library

cat("Loading Packages...\n")
library("dplyr")
library("tibble")
library("rsq")
library("car")
library("Rcmdr")
library("hash")
library("multcompView")
library("HyperG")
library("plotly")
library("htmlwidgets")
library("magrittr")
library("tidyr")
library("multiApply")

library("viridis")
library("pheatmap")
#library("roxygen2")

# SWITCHBOARD variable/function setup to quickly adjust elements present throughout the program.
# Hacky way of getting consistent legend generation, also controls value rounding over the program
#   and some constant definitions
# This section provides a component of automation - allowing changes to common 
# elements throughout the program to be made in a centralized manner that propagates 
# to all functions and codeblocks which use that information.

#   Dataset over which analysis is done.
cat("Loading Dataset of Interest...\n")
SWITCHBOARD.csvMAINFILE <- read.csv(file = 'PARL0_06202022.csv')

#put below code in CALC.AUGMENT()

SWITCHBOARD.csvAUGMFILE <- SWITCHBOARD.csvMAINFILE %>%
  mutate(H_div_W = height / width,
         FW_div_W = fresh_weight / width,
         FW_div_D = fresh_weight / diameter,
         FW_div_H = fresh_weight / height,
         FW_div_T = fresh_weight / thickness,
         D_div_W = diameter / width) %>%
  merge(read.csv('Pad_Area_Estimations.csv', fileEncoding = 'UTF-8-BOM'), by = "completeID") %>%
  mutate(Theo_Area = pi*height*width*0.25) %>%
  mutate(PartRatio = ((height-width)/(height+width))^2) %>%
  mutate(Pade_Peri = pi*(height+width)*(64-3*PartRatio^2)/(64-16*PartRatio)) %>%
  mutate(Pade_Derived_Diam = Pade_Peri/pi)



# names(SWITCHBOARD.csvAUGMFILE) >> 
# [1] "completeID"   "fresh_weight" "width"        "height"       "diameter"    
# [6] "thickness"    "accession"    "species"      "H_div_W"      "FW_div_W"    
# [11] "FW_div_D"     "FW_div_H"     "FW_div_T"     "D_div_W"      "Area"   

cat("::| Constructing Accession List\n")
SWITCHBOARD.ACCESSIONLIST <- c(242, 246, 319, 325, 326, 390, 572, 580, 582, 584, 585, 839, 845, 854)

cat("::| Setting Autogenerated Regression Figure Axes\n")
DATA_OBJECTS.MODELS_intermeasure <- tribble(
  ~ xname, ~ yname,
  'width',     'fresh_weight',
  'height',    'fresh_weight',
  'diameter',  'fresh_weight',
  'thickness', 'fresh_weight',
  'width',     'height',
  'width',     'diameter',
  'width',     'thickness',
  'height',    'diameter',
  'height',    'thickness',
  'diameter',  'thickness',
)

SWITCHBOARD.qqMeasures_VEC <- c("width", "diameter", "height", "thickness", "fresh_weight")

SWITCHBOARD.models_multiplicative <- c(
  "fresh_weight~width",
  "fresh_weight~height",
  "fresh_weight~diameter",
  "fresh_weight~thickness",
  "fresh_weight~width+height",
  "fresh_weight~width+diameter",
  "fresh_weight~width+thickness",
  "fresh_weight~height+diameter",
  "fresh_weight~height+thickness",
  "fresh_weight~diameter+thickness",
  "fresh_weight~width+height+diameter",
  "fresh_weight~width+height+thickness",
  "fresh_weight~width+diameter+thickness",
  "fresh_weight~height+diameter+thickness",
  "fresh_weight~width+height+diameter+thickness",
  "fresh_weight~width*height",
  "fresh_weight~width*diameter",
  "fresh_weight~width*thickness",
  "fresh_weight~height*diameter",
  "fresh_weight~height*thickness",
  "fresh_weight~diameter*thickness",
  "fresh_weight~width*height*diameter",
  "fresh_weight~width*height*thickness",
  "fresh_weight~width*diameter*thickness",
  "fresh_weight~height*diameter*thickness",
  "fresh_weight~width*height*diameter*thickness"
  #"I(width*height*diameter*thickness)"
)

SWITCHBOARD.models_elliptical <- c(
  "fresh_weight~Area",
  "fresh_weight~Theo_Area",
  "fresh_weight~Area+thickness",
  "fresh_weight~Theo_Area+thickness",
  "fresh_weight~Theo_Area+thickness+Pade_Derived_Diam",
  "fresh_weight~Area*thickness",
  "fresh_weight~Theo_Area*thickness",
  "fresh_weight~Theo_Area*thickness*Pade_Derived_Diam"
)

DATA_OBJECTS.MODELS_intermeasure$models <- apply(DATA_OBJECTS.MODELS_intermeasure[, c("yname", "xname")], 1, paste, collapse = "~") 

DATA_OBJECTS.MODELS_multiplicative <- as.data.frame(SWITCHBOARD.models_multiplicative) %>%
  set_colnames(c("models"))

DATA_OBJECTS.MODELS_elliptical <- as.data.frame(SWITCHBOARD.models_elliptical) %>%
  set_colnames(c("models"))

#DATA_OBJECTS.MODELS_intermeasure



# CALC.ModelGenerator <- function(df_in, fill_models_df) {
#   fits_frame <- data.frame(accession = SWITCHBOARD.ACCESSIONLIST)
#   for(model in fill_models_df$models) {
#     new_models <- df_in %>%
#       group_by(accession) %>%
#       do(model = lm(model, data = .)) %>%
#       setNames(c("accession", model)) %>%
#       column_to_rownames("accession")
#     fits_frame <- cbind(fits_frame, new_models[model])
#   }
#   return(fits_frame)
# }





DEBUGG.Leverage <- function(model_df) {
  return_model <- model_df
  #print(names(model_df))
  for (col in 2:ncol(return_model)) {
    #print(names(return_model[col]))
    for (row in 1:nrow(return_model)) {
      #print(CALC.ModelIndexHighLeverage(return_model[row, col][[1]]))
      #return_model[row, col] <- CALC.ModelHighLeverage(return_model[row, col][[1]])
    }
  }
  #return(return_model)
}



#FIGURE OUT HOW TO ITERATIVELY FILTER OUT THE DATAPOINTS BASED ON HIGH LEVERAGE 3*P/N

#Creating initial linear regressions object
DATA_OBJECTS.LinearRegressions_DF <- CALC.ModelGenerator(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.MODELS_intermeasure)

DATA_OBJECTS.MultiplicativeRegressions_DF_UNFILT <- CALC.ModelGenerator(SWITCHBOARD.csvAUGMFILE, DATA_OBJECTS.MODELS_multiplicative)
DATA_OBJECTS.EllipticalRegressions_DF_UNFILT <- CALC.ModelGenerator(SWITCHBOARD.csvAUGMFILE, DATA_OBJECTS.MODELS_elliptical)


#]]DEBUG
#filterModelIDs <- UTIL.CollectFilterModelIDs(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.LinearRegressions_DF)

test_aug_filt <- UTIL.TagFilterByID(SWITCHBOARD.csvMAINFILE, filterModelIDs)
print(test_aug_filt[which(test_aug_filt$tagged_hiLeverage == F),])


#DEBUGG.Leverage(DATA_OBJECTS.LinearRegressions_DF)





# MAKER.BoxplotMaker <- function(dataset, measure, colors) {
#   TUKEY <- CALC.tukeyTester(dataset, measure)
#   LABELS <- CALC.tukeyLabel_DF(TUKEY)
#   target_boxplot <- boxplot(dataset[[measure]] ~ dataset$accession, ylim=c(min(dataset[[measure]]) , 1.1*max(dataset[[measure]])) , col=colors[as.numeric(LABELS[,1])] , ylab="value" , main="")
#   target_boxplot
#   return(target_boxplot)
# }

#MAKER.BoxplotMaker(SWITCHBOARD.csvAUGMFILE, "height", EXAMPLE_COLORS)

#---------------------





#COMPILE.R2heatmap <- function(fits_df, filenamestring, subfolder) {
#   CALC.df_R2(fits_df) %T>%
#     UTIL.quickCSV(filenamestring, subfolder) %>%
#     GRAPHER.R2heatmap(filenamestring, subfolder)
# }
#COMPILE.SBCheatmap <- function(fits_df, filenamestring, subfolder) {
#   CALC.df_SBC(fits_df) %T>%
#     UTIL.quickCSV(filenamestring, subfolder) %>%
#     GRAPHER.SBCheatmap(filenamestring, subfolder)
# }
#COMPILE.tukeygraphs(SWITCHBOARD.csvAUGMFILE)

#]]DEBUG
#GRAPHER.tukeyHypergraph(CALC.tukeyTester(SWITCHBOARD.csvAUGMFILE, "height"), "height")




#' Generates a plot given data and a prefit linear regression function. Designed for iteration.
#' 
#' @param data_df A dataframe containing all observed data.
#' @param lmreg_df A dataframe containing all fit linear models. See CALC.ModelGenerator().
#' @param xname A string containing the independent variable.
#' @param yname A string containing the dependent variable.
#' @return NULL
#' @examples 
#' ACCESSORY.LMPlotMaker(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.LinearRegressions_DF, 242, "width", "height")

ACCESSORY.LMPlotMaker <- function(data_df, lmreg_df, accession, xname, yname) {
  model <- UTIL.toModelString(xname, yname)
  lm = lmreg_df[lmreg_df$accession == accession, model][[1]]
  plot <- ggplot(data_df[which(data_df$accession == accession),], aes(!!as.symbol(xname), !!as.symbol(yname))) +
    geom_point() +
    geom_abline(intercept = coef(lm)[1], slope = coef(lm)[2], color = "black", size = 1.5)
  show(plot)
}

#]]DEBUG
#ACCESSORY.LMPlotMaker(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.LinearRegressions_DF, 854, "height", "fresh_weight")

#]]DEBUG
#COMPILE.intermeasure(DATA_OBJECTS.LinearRegressions_DF)

main <- function() {
  
  # Augment Dataset                           PARTIAL
  # Clean Dataset on Leverage
  # Create Distribution Boxplots
  # Create Intercomparison Test               DONE
  # Create Intercomparison Test Hypergraphs   DONE
  # Create Regression Plots
  # Create Summary Stat Comparison Heatmaps
}


# TEST FOR ORDERED-NESS OF MODEL DATA INPUT
for (accession in SWITCHBOARD.ACCESSIONLIST) {
  model_df <- DATA_OBJECTS.LinearRegressions_DF
  #print(paste0("Accession: ", accession))
  for (model in names(model_df)[-1]) {
    #print(paste0("Model: ", model))
    modelobject <- CALC.ModelFetch(model_df, accession, model)
    modelgroups <- names(modelobject$model)
    #print(all(select(SWITCHBOARD.csvMAINFILE[which(SWITCHBOARD.csvMAINFILE$accession == accession),], modelgroups) == CALC.ModelFetch(model_df, accession, model)$model))
  }
}
