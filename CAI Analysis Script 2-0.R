# This program was written to automate on a large scale the statistical analyses
# done in R, in order to save time - so that minor changes to analytical processes
# may be quickly reflected across the entire analysis. This allows hours of work
# to be repeated, with or without changes, in less than two minutes while analyzing 
# thousands of datapoints.
#
# The program is interspersed with diagnostic output messages ("cat(...)") that 
# output to the console and indicate the progression of the program.
# 
# The author has not had any industry programming experience - hence, while an
# attempt has been made to document and explain the code's function to the maximum
# extent possible, there may be notable deviations from accepted coding practice.
# Contact gangres@nevada.unr.edu for questions regarding the code's function and 
# behavior.



#Establish working directory with target files.

cat("Setting Working Directory...\n")
setwd("C:\\Users\\gjang\\Documents\\GitHub\\CAI-Analysis-Script")

#Load relevant packages into library

cat("Loading Packages...\n")
library("dplyr")
library("tibble")
library("rsq")
library("car")
library("Rcmdr")
library("hash")
library("multcompView")
library("HyperG")
library("plotly")
library("htmlwidgets")
library("magrittr")
library("tidyr")
#library("roxygen2")

# SWITCHBOARD variable/function setup to quickly adjust elements present throughout the program.
# Hacky way of getting consistent legend generation, also controls value rounding over the program
#   and some constant definitions
# This section provides a component of automation - allowing changes to common 
# elements throughout the program to be made in a centralized manner that propagates 
# to all functions and codeblocks which use that information.

#   Dataset over which analysis is done.
cat("Loading Dataset of Interest...\n")
SWITCHBOARD.csvMAINFILE <- read.csv(file = 'PARL0_09092021.csv')

SWITCHBOARD.csvAUGMFILE <- SWITCHBOARD.csvMAINFILE %>%
  mutate(H_div_W = height / width,
         FW_div_W = fresh_weight / width,
         FW_div_D = fresh_weight / diameter,
         FW_div_H = fresh_weight / height,
         FW_div_T = fresh_weight / thickness,
         D_div_W = diameter / width) %>%
  merge(read.csv('Pad_Area_Estimations.csv', fileEncoding = 'UTF-8-BOM'), by = "completeID")



# HW_plot <- SWITCHBOARD.csvMAINFILE %>%
#   ggplot(aes(width, height)) +
#   geom_point() +
#   geom_smooth(method = "lm") +
#   facet_wrap(~ accession)

cat("::| Constructing Accession List\n")
SWITCHBOARD.ACCESSIONLIST <-
  c(
    242,
    246,
    319,
    325,
    326,
    390,
    572,
    580,
    582,
    584,
    585,
    839,
    845,
    854
  )

cat("::| Setting Autogenerated Regression Figure Axes\n")
SWITCHBOARD.MODELS_DF <- tribble(
  ~ xname, ~ yname,
  'width',     'fresh_weight',
  'height',    'fresh_weight',
  'diameter',  'fresh_weight',
  'thickness', 'fresh_weight',
  'width',     'height',
  'width',     'diameter',
  'width',     'thickness',
  'height',    'diameter',
  'height',    'thickness',
  'diameter',  'thickness',
)



SWITCHBOARD.MODELS_DF$models <- apply(SWITCHBOARD.MODELS_DF[, c("yname", "xname")], 1, paste, collapse = "~") 

#SWITCHBOARD.MODELS_DF

#' Creates a dataframe of all possible linear regressions with each permutation of model and accession.
#'
#' @param models_df A dataframe containing the model strings for all models of interest.
#' @return A dataframe containing every linear model in \code{models_df}, generated for each accession in \code{SWITCHBOARD.ACCESSIONLIST}
#' @examples
#' PIPELINE.ModelGenerator(SWITCHBOARD.MODELS_DF)

PIPELINE.ModelGenerator <- function(models_df) {
  fits_frame <- data.frame(accession = SWITCHBOARD.ACCESSIONLIST)
  for(model in models_df$models) {
    new_models <- SWITCHBOARD.csvMAINFILE %>%
      group_by(accession) %>%
      do(model = lm(model, data = .)) %>%
      setNames(c("accession", model))
    fits_frame <- cbind(fits_frame, new_models[model])
  }
  return(fits_frame)
}

#Creating initial linear regressions object
DATA_OBJECTS.LinearRegressions_DF <- PIPELINE.ModelGenerator(SWITCHBOARD.MODELS_DF)

#' Takes two strings and assembles them into a regression-ready string.
#' 
#' @param xname The independent variable.
#' @param yname The dependent variable.
#' @return A string of the form "yname ~ xname"
#' @examples 
#' UTIL.toModelString("width", "height")

#Utility Function: Converting two strings into a simple linear regression model string
UTIL.toModelString <- function(xname, yname) {
  return(paste0(yname, "~", xname))
}


ACCESSORY.BoxplotMaker <- function() {
  
}
#---------------------
CALC.tukeyTester <- function(dataset, measure) {

  model=lm(dataset[[measure]] ~ factor(dataset$accession))
  ANOVA=aov(model)
  TUKEY <- TukeyHSD(x=ANOVA, 'factor(dataset$accession)', conf.level=0.95)
  #plot(TUKEY, las=1 , col="brown")
  return(TUKEY)
}

GRAPHER.tukeyPlotter <- function(tukey_results) {
  tukeyplot <- plot(tukey_results, las=1 , col="gray29")
  show(tukeyplot)
  #return(tukeyplot)
}

CALC.tukeyLabel_DF <- function(tukey_results) {
  Tukey.levels <- tukey_results[["factor(dataset$accession)"]][,4]
  Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
  Tukey.labels$accession=rownames(Tukey.labels)
  rownames(Tukey.labels) <- NULL
  Tukey.labels=Tukey.labels[order(Tukey.labels$accession) , ]
  return(Tukey.labels)
}
CALC.tukeyRelation <- function(tukey_labels) {
  tukey_relation <- tukey_labels
  tukey_relation$Letters <- sapply(tukey_relation$Letters, strsplit, split = "")
  tukey_relation <- separate_rows(tukey_relation, Letters)
  tukey_relation <- tukey_relation[which(tukey_relation$Letters != ""),]
  print(tukey_relation)
  return(tukey_relation)
}
CALC.tukeyEdgelist <- function(tukey_relation) {
  tukey_edgelist <- split(tukey_relation$accession, tukey_relation$Letters)
  return(tukey_edgelist)
}

GRAPHER.tukeyHypergraph <- function(tukey_test, measure) {
  
  tukey_labels <- CALC.tukeyLabel_DF(tukey_test)
  tukey_relate <- CALC.tukeyRelation(tukey_labels)
  tukey_edglst <- CALC.tukeyEdgelist(tukey_relate)
  
  tukey_hgraph <- hypergraph_from_edgelist(tukey_edglst)
  hypergraph_plot <- plot(tukey_hgraph)
  text(0, 1.25, cex = 1.75, paste0("Hypergraph of ", measure))
}

GRAPHER.tukeyHypergraph(CALC.tukeyTester(SWITCHBOARD.csvAUGMFILE, "height"), "height")

# CURRENT ISSUE: tukeyLabelDF does not work. It needs to return the results of the generate_label_df function in the PIPELINE function


#PIPELINE.tukeyAnalyzer(SWITCHBOARD.csvAUGMFILE, "height")


#' Generates a plot given data and a prefit linear regression function. Designed for iteration.
#' 
#' @param data_df A dataframe containing all observed data.
#' @param lmreg_df A dataframe containing all fit linear models. See PIPELINE.ModelGenerator().
#' @param xname A string containing the independent variable.
#' @param yname A string containing the dependent variable.
#' @return NULL
#' @examples 
#' ACCESSORY.LMPlotMaker(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.LinearRegressions_DF, 242, "width", "height")

ACCESSORY.LMPlotMaker <- function(data_df, lmreg_df, accession, xname, yname) {
  model <- UTIL.toModelString(xname, yname)
  lm = lmreg_df[lmreg_df$accession == accession, model][[1]]
  plot <- ggplot(data_df[which(data_df$accession == accession),], aes(!!as.symbol(xname), !!as.symbol(yname))) +
    geom_point() +
    geom_abline(intercept = coef(lm)[1], slope = coef(lm)[2], color = "black", size = 1.5)
  show(plot)
}


ACCESSORY.LMPlotMaker(SWITCHBOARD.csvMAINFILE, DATA_OBJECTS.LinearRegressions_DF, 854, "height", "fresh_weight")





main <- function() {
  # Augment Dataset
  # Clean Dataset on Leverage
  # Create Distribution Boxplots
  # Create Intercomparison Test
  # Create Intercomparison Test Hypergraphs
  # Create Regression Plots
  # Create Summary Stat Comparison Heatmaps
}