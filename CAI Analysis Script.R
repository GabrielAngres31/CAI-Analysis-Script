# This program was written to automate on a large scale the statistical analyses
# done in R, in order to save time - so that minor changes to analytical processes
# may be quickly reflected across the entire analysis. This allows hours of work
# to be repeated, with or without changes, in less than two minutes while analyzing 
# thousands of datapoints.
#
# The program is interspersed with diagnostic output messages ("cat(...)") that 
# output to the console and indicate the progression of the program.
# 
# The author has not had any industry programming experience - hence, while an
# attempt has been made to document and explain the code's function to the maximum
# extent possible, there may be notable deviations from accepted coding practice.
# Contact gangres@nevada.unr.edu for questions regarding the code's function and 
# behavior.



#Establish working directory with target files.

cat("Setting Working Directory...\n")
setwd("C:\\Users\\gjang\\Documents\\GitHub\\CAI-Analysis-Script")

#Load relevant packages into library

cat("Loading Packages...\n")
library("dplyr")
library("tibble")
library("rsq")
library("car")
library("Rcmdr")
library("hash")
library("multcompView")
library("HyperG")

# SWITCHBOARD variable/function setup to quickly adjust elements present throughout the program.
# Hacky way of getting consistent legend generation, also controls value rounding over the program
#   and some constant definitions
# This section provides a component of automation - allowing changes to common 
# elements throughout the program to be made in a centralized manner that propagates 
# to all functions and codeblocks which use that information.

#   Dataset over which analysis is done.
cat("Loading Dataset of Interest...\n")
SWITCHBOARD.csvMAINFILE <- read.csv(file = 'PARL0_09092021.csv')

cat("Configuring Program Constants in Switchboard...\n")
#   Working directory for program to draw files from.
#   NOTE: This directory should be replaced as appropriate depending on where 
#   the source files for the program have been downloaded.

SWITCHBOARD.DIRECTORY <-
  "C:\\Users\\gjang\\Documents\\GitHub\\CAI-Analysis-Script\\"

#   String storage for quick legend generation.
#   Where the "magic literals" are defined.
cat("::| Setting Figure Legend String Tools\n")
SWITCHBOARD.strALLACCESSIONS <- "All Accessions"
SWITCHBOARD.strALLDATA <- "Entire"

#   Constant for values presentation in figures.

cat("::| Setting Global Rounding Value for Figures to ")
SWITCHBOARD.roundto <- 3
cat(SWITCHBOARD.roundto, "decimal places\n")

#   Field determining how outliers are sorted in successively filtered versions of the data.
cat("::| Choosing Data Cleaning Basis to ")
SWITCHBOARD.strCLEANONLIST <-
  c("D_div_W")
cat(SWITCHBOARD.strCLEANONLIST, "\n")

cat("::| Setting Dataset Thresholds to [ ")
SWITCHBOARD.strTHRESHOLDS <-
  c(
    "100",
    "95",
    "90"
  )
cat(SWITCHBOARD.strTHRESHOLDS, "]\n")

#   List-style string/constant storages for efficient iteration.
cat("::| Constructing Accession List\n")
SWITCHBOARD.strACCESSIONLIST <-
  c(
    "242",
    "246",
    "319",
    "325",
    "326",
    "390",
    "572",
    "580",
    "582",
    "584",
    "585",
    "839",
    "845",
    "854"
  )

cat("::| Setting R^2/SBC Dataframe Headers: Gen 1...\n")
SWITCHBOARD.strMODELLIST_gen1 <-
  c(
    "Accession",
    "W",
    "H",
    "D",
    "Th",
    "WH",
    "WD",
    "WT",
    "HD",
    "HT",
    "DT",
    "WHD",
    "WHT",
    "WDT",
    "HDT",
    "HWDT"
  )

cat("::| Setting R^2/SBC Dataframe Headers: Gen 2...\n")
SWITCHBOARD.strMODELLIST_gen2 <-
  c(
    "Accession",
    "Ae",
    "AeT",
    "At",
    "AtT",
    "AtTDp"
  )

cat("::| Setting Tukey Plot Iterables\n")
SWITCHBOARD.strTUKEYMEASURESLIST <-
  c(
    "width",
    "thickness",
    "height",
    "fresh_weight",
    "diameter"
  )

cat("::| Setting Dry Weight Ratios\n")
SWITCHBOARD.FRESH_DRY_RAWS <- list(
  c(9.17, 0.60),
  c(8.48, 0.49),
  c(8.73, 0.60),
  c(10.23, 0.68),
  c(5.76, 0.49),
  c(10.65, 0.89),
  c(10.37, 0.65),
  c(5.47, 0.40),
  c(8.11, 0.57),
  c(9.71, 0.66),
  c(4.56, 0.32),
  c(3.97, 0.33),
  c(7.59, 0.71),
  c(2.31, 0.21)
)

cat("::| Applying Dry Weight Calculations\n")
SWITCHBOARD.AVG_FRESH_DRY_WEIGHTS <-
  hash(SWITCHBOARD.strACCESSIONLIST, SWITCHBOARD.FRESH_DRY_RAWS)

cat("::| Setting QQ-Plot Iterables\n")
SWITCHBOARD.strQQMEASURESLIST <-
  c(
    "fresh_weight",
    "width",
    "height",
    "diameter",
    "thickness",
    "D_div_W",
    "FW_div_H",
    "FW_div_W",
    "FW_div_D",
    "FW_div_T",
    "dry_weight"
  )

#   Centralized list of all individual plots to be generated.
cat("::| Setting Autogenerated Regression Figure Axes\n")
SWITCHBOARD.GRAPHS_LIST <- tribble(
  ~ xname, ~ yname,
  'width',     'fresh_weight',
  'height',    'fresh_weight',
  'diameter',  'fresh_weight',
  'thickness', 'fresh_weight',
  'D_div_W',   'fresh_weight',
  'width',     'height',
  'width',     'diameter',
  'width',     'thickness',
  'height',    'diameter',
  'height',    'thickness',
  'diameter',  'thickness',
  'D_div_W',   'dry_weight'
  #  'add_HW', 'thickness',
  #  'add_HW', 'fresh_weight',
  #  'add_HWT', 'fresh_weight',
  #  'add_DT', 'fresh_weight',
  #  'mul_HWDT', 'fresh_weight'
)

#   Removing any amount of datapoints based on researcher's discretion if a datapoint cannot be 
#     repaired or restored from earlier records.

cat("Establishing Utility Functions...\n")
cat("::| Manual Datapoint Removal Utility\n")
SWITCHBOARD.funcHARDREMOVE <- function(dataset, padID, reason) {
  dataset <- filter(dataset, completeID != paste0("PARL ", padID))
  message(paste0("Removed PARL_", padID, " for: ", reason))
}

#   Translation function for converting csv field names to human-readable strings.
cat("::| Human-Readable Dataset Name Adapter\n")
SWITCHBOARD.colnameToLegend <- function(column_text) {
  legname <- switch(
    column_text,
    "width" = "Width",
    "height" = "Height",
    "diameter" = "Diameter",
    "thickness" = "Thickness",
    "fresh_weight" = "Fresh Weight",
    'D_div_W' = "Diameter / Width",
    'FW_div_H' = 'Fresh Weight / Height',
    'FW_div_W' = 'Fresh Weight / Width',
    'FW_div_D' = 'Fresh Weight / Diameter',
    'FW_div_T' = 'Fresh Weight / Thickness',
    "dry_weight" = "Dry Weight"
  )
  return(legname)
}

# Dataframe for outputting R^2 values of correlation plots

cat("Constructing R^2 Dataframe Shell...\n")
csvR2Frame <-
  data.frame(
    Dataset = character(),
    Graph = character(),
    R2 = double(),
    Mode = character()
  )



# From here on, three main classes of function are defined.
#   |> main(), which is defined last and is responsible for all other function calls
#   |> PIPELINE, an object holding functions that call each other in a nested fashion
#   |> ACCESSORY, an object holding functions not part of the central analysis, but which are still called by main()

# The following ACCESSORY Functions help with error removal.
# tagBySTDDEV -- Called by ErrorCleaning before (in?) removeByID, this tags observations
# if they are more than n = 3 standard deviations away from the mean in a given parameter.
# However, may have to remove as fresh weight is not normally distributed.

cat("Constructing Accessory Functions...\n")

cat("::| Quick .PNG Maker")
ACCESSORY.quick_png <- function(directory, subfolder, filenamestring) {
  png(paste0(directory, "\\", subfolder, "\\", filenamestring, ".png"))
}

cat("::| Filtering Criterion Calculator\n")
ACCESSORY.tagBySTDDEV <-
  function(dataset, an_accession, threshold) {
    blacksite <- vector()
    dataset_accessionfilter <-
      filter(dataset, accession == an_accession)
    for (columnname in SWITCHBOARD.strCLEANONLIST) {
      tempcol <-
        dataset_accessionfilter[[columnname]]
      meanCol <- mean(tempcol)
      STDCol <- sd(tempcol)
      bound_upper <- (meanCol + (STDCol * as.numeric(threshold)))
      bound_lower <- (meanCol - (STDCol * as.numeric(threshold)))
      detention <-
        filter(
          dataset_accessionfilter,
          !!as.symbol(columnname) < bound_lower |
            !!as.symbol(columnname) > bound_upper
        )
      blacklist <- as.vector(detention$completeID)
      blacksite <- c(blacksite, blacklist)
    }
    return(blacksite)
  }

# ErrorCleaning uses tagBySTDDEV to remove datapoint rows from the frame according to whether they exceed a two-tailed
#   percentile threshold.

cat("::| Error Cleaning on Criterion\n")
ACCESSORY.ErrorCleaning <- function(dataset, perc_threshold) {
  rawblock <- dataset
  dev_threshold <- qnorm((100 - ((100 - perc_threshold ) / 2)) / 100)
  for (accession in SWITCHBOARD.strACCESSIONLIST) {
    blacksite <-
      ACCESSORY.tagBySTDDEV(dataset, accession, dev_threshold)
    rawblock <-
      filter(rawblock,!(rawblock$completeID %in% blacksite))
  }
  finalDataset <- rawblock
  return(finalDataset)
}

# DataSubset returns a subsection of the dataframe which only contains a particular accession.
#   Used to make plotting code cleaner.
cat("::| Dataset Subsetting Function\n")
ACCESSORY.DataSubset <-
  function(filter_data,
           filter_accession,
           dataset_in) {
    if (filter_data == SWITCHBOARD.strALLDATA) {
      F_data <- dataset_in
    } else {
      F_data <- filter(dataset_in, dataset == filter_data)
    }
    if (filter_accession == SWITCHBOARD.strALLACCESSIONS) {
      F_data_accession <- F_data
    } else {
      F_data_accession <-
        filter(F_data, accession == filter_accession)
    }
    if (nrow(F_data_accession) == 0) {
      return(NULL)
    } else {
      return(F_data_accession)
    }
  }

# This PIPELINE function, PlotRegress, takes two fields of the analysis dataframe and generates linear or double-log
#   regression plots given the entire dataset or only a particular accession.

cat("Constructing Pipeline Functions...\n")
cat("::| Linear Regression Modeler\n")
PIPELINE.PlotRegress = function(x,
                                y,
                                year = SWITCHBOARD.strALLDATA,
                                accession = SWITCHBOARD.strALLACCESSIONS,
                                dataset_in,
                                graphmode)
{
  subset <-
    ACCESSORY.DataSubset(year, accession, dataset_in)
  if (is.null(subset) == TRUE) {
    return(NULL)
  }
  xlab = SWITCHBOARD.colnameToLegend(x)
  ylab = SWITCHBOARD.colnameToLegend(y)
  subslice = select(subset, x, y)
  x_data = subslice[[x]] #colnameToCol(x, subslice)
  y_data = subslice[[y]] #colnameToCol(y, subslice)
  
  if (graphmode == "Double Log") {
    targetline = lm(log(y_data) ~ log(x_data), data = subslice)
  } else if (graphmode == "Double Linear") {
    targetline = lm(y_data ~ x_data, data = subslice)
  }
  
  rsquare = rsq(targetline, type = "sse")
  intercept <- coefficients(targetline)[1]
  slope <- coefficients(targetline)[2]
  details <-
    paste0(
      "y_0 = ",
      round(intercept, SWITCHBOARD.roundto),
      ", m = ",
      round(slope, SWITCHBOARD.roundto),
      collapse = " "
    )
  
  csvR2Frame <<- rbind(
    csvR2Frame,
    data.frame(
      "Dataset" = paste0(year, " Dataset ", accession, collapse = " "),
      "Graph" = paste0(xlab, " vs. ", ylab,
                       collapse = " "),
      "R2" = round(rsquare, SWITCHBOARD.roundto),
      "Mode" = graphmode
    )
  )
  plot(
    x_data, y_data,
    type = "p",
    log = ifelse(graphmode == "Double Log", "xy", ""),
    cex = 0.8,
    sub = paste0(details, ", R^2 =", round(rsquare, SWITCHBOARD.roundto), ", N = ", nrow(subslice)),
    main = paste0(
      xlab, " vs. ", ylab, "\n",
      year, " Dataset, ", accession, 
      "Mode - ", graphmode,
      collapse = " "
    ),
    xlab = xlab, ylab = ylab
  )
  if (graphmode == "Double Log") {
    lines(x_data, exp(predict(targetline, newdata = list(x_data = x_data))) , col = "grey")
  } else if (graphmode == "Double Linear") {
    lines(x_data, predict(targetline, newdata = list(x_data = x_data)) , col = "grey")
  }
}

# CorrPlotsGenerator iterates over the SWITCHBOARD.GRAPHS_LIST to generate all of the figures and place them in 
#   a single .pdf file. TODO: Generate individual .png files for in-document placement

cat("::| Linear Regression Grapher\n")
PIPELINE.CorrPlotsGenerator <-
  function(figure_guide,
           year = SWITCHBOARD.strALLDATA,
           accession = SWITCHBOARD.strALLACCESSIONS,
           dataset_in) {
    for (i in 1:nrow(figure_guide)) {
      for (graphmode in c("Double Log", "Double Linear")) {
        row <- figure_guide[i, ]
        PIPELINE.PlotRegress(row$xname,
                             row$yname,
                             year,
                             accession,
                             dataset_in,
                             graphmode)
      }
    }
  }

# qqGen creates QQ plots for each measure, for each accession, for a particular level of data filtration.
cat("::| QQ Linear Measure Plotter\n")
PIPELINE.qqGen <-
  function(accession, column, dataset_in, threshold) {
    subsetA <-
      ACCESSORY.DataSubset(SWITCHBOARD.strALLDATA,
                           filter_accession = accession,
                           dataset_in = dataset_in)
    title <-
      paste0(accession, ", ", column)
    
    ACCESSORY.quick_png(SWITCHBOARD.DIRECTORY, "QQPlot_Images", paste0(column, "--", accession, "_LIN_", threshold, "th"))
    
    qqPlot(subsetA[[column]], main = title, envelope = 0.95)
    dev.off()
  }

# qqGenLog does the same thing as qqGen, but applies a log transformation to the data first.

cat("::| QQ Log-Log Measure Plotter\n")

PIPELINE.qqGenLog <-
  function(accession, column, dataset_in, threshold) {
    subsetA <-
      ACCESSORY.DataSubset(SWITCHBOARD.strALLDATA,
                           filter_accession = accession,
                           dataset_in = dataset_in)
    title <-
      paste0(accession, ", ", column)
   
    ACCESSORY.quick_png(SWITCHBOARD.DIRECTORY, "QQPlot_Images", paste0(column, "--", accession, "_LOG_", threshold, "th"))

    qqPlot(log(subsetA[[column]]), main = title, envelope = 0.95)
    dev.off()
  }

# qqGenLog does the same thing as qqGen, but applies a square-root transformation to the data first.

cat("::| QQ Square Root Measure Plotter\n")

PIPELINE.qqGenSqrt <-
  function(accession, column, dataset_in = dataset_in, threshold) {
    subsetA <-
      ACCESSORY.DataSubset(SWITCHBOARD.strALLDATA, filter_accession = accession, dataset_in)
    title <-
      paste0(accession, ", ", column)
    
    ACCESSORY.quick_png(SWITCHBOARD.DIRECTORY, "QQPlot_Images", paste0(column, "--", accession, "_SQRT_", threshold, "th"))
    
    qqPlot(sqrt(subsetA[[column]]), main = title, envelope = 0.95)
    dev.off()
  }

cat("::| Tukey Intercomparison\n")
PIPELINE.tukeyAnalyzer <- function(dataset, threshold, measure) {
  
  
  generate_label_df <- function(tukey_in, variable){
    # Extract labels and factor levels from Tukey post-hoc
    Tukey.levels <- tukey_in[[variable]][,4]
    Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
    
    #I need to put the labels in the same order as in the boxplot :
    Tukey.labels$accession=rownames(Tukey.labels)
    Tukey.labels=Tukey.labels[order(Tukey.labels$accession) , ]
    return(Tukey.labels)
  }
  
  model=lm( dataset[[measure]] ~ factor(dataset$accession) )
  ANOVA=aov(model)
  TUKEY <- TukeyHSD(x=ANOVA, 'factor(dataset$accession)', conf.level=0.95)
  LABELS <- generate_label_df(TUKEY, "factor(dataset$accession)")

  tukeyMeanMaker <- function(tukey_results) {
   
    
    ACCESSORY.quick_png(SWITCHBOARD.DIRECTORY, "TukeyPlots\\Pairwise_Mean_Comparisons", paste0(measure, "--", threshold, "th"))
    
    plot(tukey_results, las=1 , col="gray29")
    dev.off()
  }
  
  tukeyHypergraphMaker <- function(tukey_labels) {
    
    groupElements <- c("a")
    for (grouptags in tukey_labels$Letters) {
      for (char in strsplit(grouptags, "")) {
        groupElements <- sort(unique(append(groupElements, char)))
      }
    }
    
    collectGroup <- function(tukeyResults, targetgroup) {
      basket <- c()
      for (accession in row.names(tukeyResults)) {
        if (grepl(targetgroup, tukeyResults[accession, 1])) {
          basket <- append(basket, accession)
        }
      }
      return(basket)
    }
    
    hypergroups <- as.list(rep(".", length(groupElements))) 
    names(hypergroups) <- as.vector(groupElements)
    for (group in groupElements) {
      hypergroups[[group]] <- collectGroup(tukey_labels, group)
    }
    
    generated_hypergraph <- hypergraph_from_edgelist(hypergroups)
    
    ACCESSORY.quick_png(SWITCHBOARD.DIRECTORY, "TukeyPlots\\Representative_Hypergraphs", paste0(measure, "--", threshold, "th"))
    
    plot(generated_hypergraph)
    text(0, 1.25, 
         cex = 1.75,
         paste0(
           "Hypergraph of ", SWITCHBOARD.colnameToLegend(measure), " - Threshold: ", threshold, "th"
           )
         )
    dev.off() 
  }
  
  tukeyMeanMaker(TUKEY)
  tukeyHypergraphMaker(LABELS)
}

cat("::| Master Plot Compiler\n")
PIPELINE.PlotCompiler <- function(dataset_in, threshold) {
  for (dataset in c(SWITCHBOARD.strALLDATA)) {
    for (accession in c(
      SWITCHBOARD.strALLACCESSIONS,
      SWITCHBOARD.strACCESSIONLIST
    )) {
      PIPELINE.CorrPlotsGenerator(SWITCHBOARD.GRAPHS_LIST, dataset, accession, dataset_in)
    }
  }
  
  for (accession in SWITCHBOARD.strACCESSIONLIST) {
    for (measure in SWITCHBOARD.strQQMEASURESLIST) {
      PIPELINE.qqGen(accession, measure, dataset_in, threshold)
    }
  }
  for (measure in SWITCHBOARD.strTUKEYMEASURESLIST) {
    PIPELINE.tukeyAnalyzer(dataset_in, threshold, measure)
  }
}


cat("Accessory Function: Model Stats Finder...\n")
ACCESSORY.statfinder <- function (dataset, models_x) {
  models_df <-
    data.frame(Name = character(),
               AdjRsq = numeric(),
               SBC = numeric()
    )
  for (targetmodel_x in models_x) {
    formula_fresh <- as.formula(paste0("fresh_weight ~ ", targetmodel_x))
    formula_fits <- lm(formula_fresh, dataset)
    formula_summ <- summary(formula_fits)
    models_df <- rbind(models_df,
                       data.frame(
                         Name = targetmodel_x,
                         AdjRsq = formula_summ[["adj.r.squared"]],
                         SBC = BIC(formula_fits)
                       )
      )
  } 
  return(models_df)
}

cat("Accessory Function: Model Stats Compiler...\n")
ACCESSORY.statextractor <- function(dataset, models_x, array_fill, threshold) {
  bucket_array <- array_fill
  for (accession in c(SWITCHBOARD.strALLACCESSIONS, as.vector(SWITCHBOARD.strACCESSIONLIST))) {
    loadup_df <- ACCESSORY.statfinder(ACCESSORY.DataSubset(SWITCHBOARD.strALLDATA, accession, dataset), models_x)
    for (model in models_x) {
      for (stat in c("AdjRsq", "SBC")) {
        bucket_array[as.character(threshold),
                               accession,
                               model,
                               stat] <- loadup_df[loadup_df$Name == model, stat]
      }
    }
  }
  return(bucket_array)
}


cat("Accessory Function: List-Zipper...\n")
ACCESSORY.vector2list_zip <- function (elements, elem_names) {
  result_list <- as.list(elements)
  names(result_list) <- as.vector(elem_names)
  return(result_list)
}

cat("Constructing All-Subsets Linear Regression Dataframe Shell...\n")

SUBSETS_STATS.thresholds <- SWITCHBOARD.strTHRESHOLDS
SUBSETS_STATS.accessions <- c(
  SWITCHBOARD.strALLACCESSIONS,
  SWITCHBOARD.strACCESSIONLIST
)
SUBSETS_STATS.1stgen.modelnames <- c(
  "width",
  "height",
  "diameter",
  "thickness",
  "width*height",
  "width*diameter",
  "width*thickness",
  "height*diameter",
  "height*thickness",
  "diameter*thickness",
  "width*height*diameter",
  "width*height*thickness",
  "width*diameter*thickness",
  "height*diameter*thickness",
  "width*height*diameter*thickness"
)
SUBSETS_STATS.1stgen.abbreviate <- SWITCHBOARD.strMODELLIST_gen1[2:length(SWITCHBOARD.strMODELLIST_gen1)]

SUBSETS_STATS.2ndgen.modelnames <- c(
  "Area",
  "Area*thickness",
  "Theo_Area",
  "Theo_Area*thickness",
  "Theo_Area*thickness*Pade_Derived_Diam"
)
SUBSETS_STATS.2ndgen.abbreviate <- SWITCHBOARD.strMODELLIST_gen2[2:length(SWITCHBOARD.strMODELLIST_gen2)]
  
SUBSETS_STATS.statistics <- c("AdjRsq", "SBC")

SUBSETS_STATS.1stgen.statsArray <- array(1:as.numeric(length(SUBSETS_STATS.thresholds) 
                                                    * length(SUBSETS_STATS.accessions) 
                                                    * length(SUBSETS_STATS.1stgen.modelnames) 
                                                    * length(SUBSETS_STATS.statistics)
                                                     ),
                                         dim = c(
                                                 length(SUBSETS_STATS.thresholds),
                                                 length(SUBSETS_STATS.accessions), 
                                                 length(SUBSETS_STATS.1stgen.modelnames), 
                                                 length(SUBSETS_STATS.statistics)
                                                ),
                                         dimnames = list(
                                                         SUBSETS_STATS.thresholds,
                                                         SUBSETS_STATS.accessions,
                                                         SUBSETS_STATS.1stgen.modelnames,
                                                         SUBSETS_STATS.statistics
                                                        )
                                )

SUBSETS_STATS.2ndgen.statsArray <- array(1:as.numeric(length(SUBSETS_STATS.thresholds)
                                                      * length(SUBSETS_STATS.accessions) 
                                                      * length(SUBSETS_STATS.2ndgen.modelnames) 
                                                      * length(SUBSETS_STATS.statistics)
                                                      ),
                                         dim = c(
                                                 length(SUBSETS_STATS.thresholds),
                                                 length(SUBSETS_STATS.accessions), 
                                                 length(SUBSETS_STATS.2ndgen.modelnames), 
                                                 length(SUBSETS_STATS.statistics)
                                                ),
                                         dimnames = list(
                                           SUBSETS_STATS.thresholds,
                                           SUBSETS_STATS.accessions,
                                           SUBSETS_STATS.2ndgen.modelnames,
                                           SUBSETS_STATS.statistics
                                         )
)

cat("\nFrame Filler Function...\n")
PIPELINE.FrameFiller <- function(modelnames, abbreviate_list, input_statsarray, model_list, pass_name, threshold) {
  
  
  RsqFrame <- data.frame(matrix(ncol = length(modelnames), nrow = 0))
  SBCFrame <- data.frame(matrix(ncol = length(modelnames), nrow = 0))
  
  dimKeyPair <- as.list(abbreviate_list)
  names(dimKeyPair) <- as.vector(modelnames)
  
  for (accession in c(SWITCHBOARD.strALLACCESSIONS, SWITCHBOARD.strACCESSIONLIST)) {
    RSQinsert <- c(accession)
    SBCinsert <- c(accession)
    for (model in c(1:length(modelnames))) {
      RSQinsert[model + 1] <-
        input_statsarray[toString(SWITCHBOARD.strTHRESHOLDS[threshold]), toString(accession), modelnames[model], "AdjRsq"]
      SBCinsert[model + 1] <-
        input_statsarray[toString(SWITCHBOARD.strTHRESHOLDS[threshold]), toString(accession), modelnames[model], "SBC"]
    }
    
    RsqFrame <- rbind(RsqFrame, RSQinsert)
    SBCFrame <- rbind(SBCFrame, SBCinsert)
  }
  
  colnames(RsqFrame) <- model_list
  write.csv(
    RsqFrame,
    paste0(
      SWITCHBOARD.DIRECTORY,
      "Correlation_Analyses\\",
      pass_name,
      "_Rsq_T_",
      SWITCHBOARD.strTHRESHOLDS[threshold],
      ".csv"
    ),
    row.names = FALSE
  )
  
  colnames(SBCFrame) <- model_list
  write.csv(
    SBCFrame,
    paste0(
      SWITCHBOARD.DIRECTORY,
      "Correlation_Analyses\\",
      pass_name,
      "_SBC_T_",
      SWITCHBOARD.strTHRESHOLDS[threshold],
      ".csv"
    ),
    row.names = FALSE
  )
  
  return(list(RsqFrame, SBCFrame))
}


cat("Dataset Preparation Function...\n")
PIPELINE.DataPrep <- function(dataset) {
  
  return_dataset <- dataset
  
  SWITCHBOARD.funcHARDREMOVE(return_dataset, "319-1-5", "Unreasonable fresh weight for size - error could not be repaired or restored.")
  
  cat("Computing Exploratory Measures\n")
  return_dataset <- return_dataset %>%
    mutate(H_div_W = height / width) %>%
    mutate(FW_div_W = fresh_weight / width) %>%
    mutate(FW_div_D = fresh_weight / diameter) %>%
    mutate(FW_div_H = fresh_weight / height) %>%
    mutate(return_dataset, FW_div_T = fresh_weight / thickness) %>%
    mutate(return_dataset, D_div_W = diameter / width)
  
  cat("Adding Manual Pad Areas...\n")
  areaFrame <-
    read.csv('Pad_Area_Estimations.csv', fileEncoding = 'UTF-8-BOM')
  return_dataset <- merge(return_dataset, areaFrame, by = "completeID")
  
  #Add Dry Weight measure for further analysis
  
  cat("Adding Dry Weight Values...\n")
  return_dataset$dry_weight <- 0
  for (accession in keys(SWITCHBOARD.AVG_FRESH_DRY_WEIGHTS)) {
    accession_set <-
      values(SWITCHBOARD.AVG_FRESH_DRY_WEIGHTS[accession])
    return_dataset$dry_weight[return_dataset$accession == accession] <-
      return_dataset$fresh_weight[return_dataset$accession == accession] * (accession_set[2] / accession_set[1])
  }
  
  #Add Parameters of Theoretical Ellipse
  
  cat("Computing Theoretical Ellipse Statistics...\n")
  return_dataset <- return_dataset %>%
    mutate(Theo_Area = pi*height*width*0.25) %>%
    mutate(PartRatio = ((height-width)/(height+width))^2) %>%
    mutate(Pade_Peri = pi*(height+width)*(64-3*PartRatio^2)/(64-16*PartRatio)) %>%
    mutate(Pade_Derived_Diam = Pade_Peri/pi)
  
  return(return_dataset)
}


cat("\n-----------------\nRUNNING MAIN FUNCTION\n-----------------\n")
main <- function() {
  #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #-----------------------------------------------
  #_______________________________________________
  #DATASET MANIPULATION, FUNCTION EXECUTION SEGMENT
  #Load Parlier csv files into memory
  workingFilenames <- list()
  
  PARLIER <- PIPELINE.DataPrep(SWITCHBOARD.csvMAINFILE)
  
  cat("Iterating Over Data Filtration Thresholds...\n")
  for (threshold_level in 1:3) {
    
    cat("::| THRESHOLD VALUE: ", SWITCHBOARD.strTHRESHOLDS[threshold_level], "\n")
    parlVersion <- ACCESSORY.ErrorCleaning(PARLIER, as.numeric(SWITCHBOARD.strTHRESHOLDS[threshold_level]))
    
    cat("::::| Writing Corrected Dataset to File...\n")
    fileTitle <- paste0(SWITCHBOARD.DIRECTORY,
                        "ref_PARL0",
                        ifelse(SWITCHBOARD.strTHRESHOLDS[threshold_level] != 100, paste0("C_", SWITCHBOARD.strTHRESHOLDS[threshold_level]), ""),
                        ".csv")
    write.csv(parlVersion,
              fileTitle,
              row.names = FALSE)
    workingFilenames <- append(workingFilenames, fileTitle)
    #---------------------------------------------------------------

    
    cat("::::| Extracting All-Subsets Linear Regression R^2/SBC...\n")
    

    SUBSETS_STATS.1stgen.statsArray <- ACCESSORY.statextractor(parlVersion,
                                                               SUBSETS_STATS.1stgen.modelnames,
                                                               SUBSETS_STATS.1stgen.statsArray,
                                                               SWITCHBOARD.strTHRESHOLDS[threshold_level]
    )
    SUBSETS_STATS.2ndgen.statsArray <- ACCESSORY.statextractor(parlVersion,
                                                               SUBSETS_STATS.2ndgen.modelnames,
                                                               SUBSETS_STATS.2ndgen.statsArray,
                                                               SWITCHBOARD.strTHRESHOLDS[threshold_level]
    )
    PIPELINE.FrameFiller(SUBSETS_STATS.1stgen.modelnames, SUBSETS_STATS.1stgen.abbreviate, SUBSETS_STATS.1stgen.statsArray, SWITCHBOARD.strMODELLIST_gen1, "G1", threshold_level) 
    PIPELINE.FrameFiller(SUBSETS_STATS.2ndgen.modelnames, SUBSETS_STATS.2ndgen.abbreviate, SUBSETS_STATS.2ndgen.statsArray, SWITCHBOARD.strMODELLIST_gen2, "G2", threshold_level) 
    
    #---------------------------------------------------------------
    cat("::::| Plotting Parameter Cross-Relations...\n")
    pdftitle <- paste(
      "Double-Log Cladode Parameter Cross-Relations",
      ifelse(SWITCHBOARD.strTHRESHOLDS[threshold_level] != 100, paste0(" Corrected - ", SWITCHBOARD.strTHRESHOLDS[threshold_level]), ""),
      ".pdf",
      sep = ""
    )
    cat("::::| Writing Cross-Relations R^2 to PDF...\n")
    pdf(pdftitle)
    PIPELINE.PlotCompiler(parlVersion, SWITCHBOARD.strTHRESHOLDS[threshold_level])
    dev.off()
    write.csv(
      csvR2Frame,
      paste(
        SWITCHBOARD.DIRECTORY,
        "R^2_Records\\Double-Log_Regression_R^2_Values",
        ifelse(SWITCHBOARD.strTHRESHOLDS[threshold_level] != 100, paste0("_Corrected_", SWITCHBOARD.strTHRESHOLDS[threshold_level]), ""),
        ".csv",
        sep = ""
      ),
      row.names = FALSE
    )
    csvR2Frame <<-
      data.frame(
        Dataset = character(),
        Graph = character(),
        R2 = double(),
        Mode = character()
      )
    
  }
  cat("Program Finished!\n")
}

main()

