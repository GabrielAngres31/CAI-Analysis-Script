
#' @name CALC.ModelGenerator
#' @description Creates a dataframe of all possible linear regressions with each permutation of model and accession.
#' @param models_df A dataframe containing the model strings for all models of interest.
#' @return A dataframe containing every linear model in \code{models_df}, generated for each accession in \code{SWITCHBOARD.ACCESSIONLIST}
#' @example CALC.ModelGenerator(SWITCHBOARD.csvMAINFILE, SWITCHBOARD.MODELS_DF)

CALC.ModelGenerator <- function(data_in, fill_models_df) {
  
  fits_frame <- data.frame(accession = SWITCHBOARD.ACCESSIONLIST)
  for(model in fill_models_df$models) {
    new_models <- data_in %>%
      group_by(accession) %>%
      do(model = lm(model, data = .)) %>%
      setNames(c("accession", model)) %>%
      column_to_rownames("accession")
    fits_frame <- cbind(fits_frame, new_models[model])
  }
  
  return(fits_frame)
}




CALC.ModelGenerator_AllAccessions_R2 <- function(data_in, fill_models_df) {
  list_out <- list()
  for(model in fill_models_df$models) {
    list_out <- list_out %>%
      append(summary(lm(model, data = data_in))[["adj.r.squared"]])
  }
  names(list_out) <- fill_models_df$models
  return(list_out)
}

CALC.ModelGenerator_AllAccessions_SBC <- function(data_in, fill_models_df) {
  list_out <- list()
  for(model in fill_models_df$models) {
    list_out <- list_out %>%
      append(BIC(lm(model, data = data_in)))
  }
  names(list_out) <- fill_models_df$models
  return(list_out)
}

########################################

#' @name CALC.ModelFetch
#' @description Retrieves a model from a dataframe constructed by a ModelGenerator() call, using the accession and model_name passed.
#'   Will throw an error to the console if the requested model is not present in the dataset.
#'   Will throw an error if the requested accession is not present in the dataset.
#' 
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @param accession An integer corresponding to an accession from the database.
#' @param model_name A string containing the model of interest to be retrieved.
#' @example CALC.ModelFetch(DATA_OBJECTS.LinearRegressions_DF, 242, "fresh_weight~width")

CALC.ModelFetch <- function(fits_df, accession, model_name) {
  if (!(model_name %in% colnames(fits_df)[-1])) {
    cat(paste0("The model '", model_name, "' is not present in ", deparse(substitute(fits_df)), "\n"))
    cat(paste0("Available models include: ", colnames(fits_df)[-1], "\n"))
    return(NULL)
  }
  if (!(accession %in% fits_df$accession)) {
    cat("Invalid Accession Number: ", accession, "\n")
    return(NULL)
  }
  return(fits_df[[model_name]][which(SWITCHBOARD.ACCESSIONLIST == accession)][[1]])
}

#' @name CALC.ModelNumHighLeverage
#' @description Given a linear model, returns the number data points whose leverage value exceeds a 3p/n threshold,
#'   where p is the number of parameters in the model, 
#'   and n is the number of data points in the model.
#' @param model_in A linear model object.

CALC.ModelNumHighLeverage <- function(model_in) {
  threshold = 3*length(model_in$coefficients)/length(model_in$model[[1]])
  return(length(which(hatvalues(model_in) > threshold)))
}

#' @name CALC.ModelIndexHighLeverage
#' @description Given a linear model, returns a vector of indices of data points whose leverage value exceeds a 3p/n threshold,
#'   where p is the number of parameters in the model, 
#'   and n is the number of data points in the model.
#' @param model_in A linear model object.

CALC.ModelIndexHighLeverage <- function(model_in) {
  threshold <- 3*length(model_in$coefficients)/length(model_in$model[[1]])
  result_index <- as.vector(which(hatvalues(model_in) > threshold))
  return(result_index)
}

#' @name CALC.ModelIndexMidLeverage
#' @description Given a linear model, returns a vector of indices of data points whose leverage value exceeds a 2p/n threshold,
#'   where p is the number of parameters in the model, 
#'   and n is the number of data points in the model.
#' @param model_in A linear model object.

CALC.ModelIndexMidLeverage <- function(model_in) {
  threshold <- 2*length(model_in$coefficients)/length(model_in$model[[1]])
  result_index <- as.vector(which(hatvalues(model_in) > threshold))
  return(result_index)
}

#' @name CALC.ModelIndexMidLeverage_Exclusive
#' @description Given two index lists of 2p/n and 3p/n threshold values, returns solely the indexes of datapoints which
#'   pass the 2p/n threshold without passing the 3p/n threshold. See CALC.ModelNumHighLeverage and CALC.ModelNumMidLeverage
#' @param result_index_MID A vector list of indices, typically generated by CALC.ModelIndexMidLeverage
#' @param result_index_HIGH A vector list of indices, typically generated by CALC.ModelIndexHighLeverage

CALC.ModelIndexMidLeverage_Exclusive <- function(result_index_MID, result_index_HIGH) {
  return(result_index_MID[-which(result_index_HIGH %in% result_index_MID)])
}

#' @name CALC.ModelValuePairsFromIndex
#' @description Given an index and a linear model object, retrieves the values of the independent and dependent variable
#' @param result_index An integer corresponding to a datapoint in the model object.
#' @param model_in A linear model object with a single predictor variable and a single dependent variable.

CALC.ModelValuePairsFromIndex <- function(result_index, model_in) {
  if (length(result_index) == 0) {
    return(NULL)
  }
  model_data <- model_in$model
  cols <- names(model_data)
  return_values_df <- data.frame(matrix(ncol = 2, nrow = length(result_index)))
  colnames(return_values_df) <- cols
  
  for (loc in length(result_index)) {
    pass_1 <- model_data[result_index[loc],][cols[1]]
    pass_2 <- model_data[result_index[loc],][cols[2]]
    row <- c(pass_1, pass_2)
    return_values_df[loc,] <- row
  }
  
  if (nrow(return_values_df) != 0) {
    return(return_values_df)
  } else {
    return(NULL)
  }
}

#' @name CALC.PadIDfromModelValuePairs
#' @description Given a dataframe of corresponding value pairs, a source dataframe, and an accession number, assigns 
#' @param value_pairs_df Value pair columns extracted from a linear model object.
#' @param data_df A source datafile containing cactus pad IDs and their corresponding measures.
#' @param accession An integer corresponding to an accession from the database.

CALC.PadIDfromModelValuePairs <- function(value_pairs_df, data_df, accession) {
  #print(length(nrow(value_pairs_df)))
  #print(value_pairs_df)
  if(nrow(value_pairs_df) == 0) {
    return(NULL)
  }
  pad_id_vec <- c()
  field_1 <- names(value_pairs_df)[1]
  field_2 <- names(value_pairs_df)[2]
  for(row in c(1:nrow(value_pairs_df))) {
    add_id <- data_df[
      which(
      data_df[[field_1]] == value_pairs_df[[field_1]][row] & 
      data_df[[field_2]] == value_pairs_df[[field_2]][row] & 
      data_df$accession == accession),
      ]$completeID
    pad_id_vec <- c(pad_id_vec, add_id)
  }
  #print(pad_id_vec)
  return(pad_id_vec)
}

########################################



CALC.tukeyColor <- function(num_colors) {
  colorarray <- c(
    rgb( 17, 119,  51, maxColorValue = 255),
    rgb( 68, 170, 153, maxColorValue = 255), 
    rgb(136, 204, 238, maxColorValue = 255),
    rgb(221, 221, 221, maxColorValue = 255),
    rgb( 51,  34, 136, maxColorValue = 255),
    rgb(170,  68, 153, maxColorValue = 255),
    rgb(136,  34,  85, maxColorValue = 255),
    rgb(204, 102, 119, maxColorValue = 255),
    rgb(221, 204, 119, maxColorValue = 255),
    rgb(153, 153,  51, maxColorValue = 255)
  )
  return(colorarray[c(1:num_colors)])
}
#------------

CALC.tukeyTester <- function(dataset, measure) {
  
  model=lm(dataset[[measure]] ~ factor(dataset$accession))
  ANOVA=aov(model)
  TUKEY <- TukeyHSD(x=ANOVA, 'factor(dataset$accession)', conf.level=0.95)
  return(TUKEY)
}

CALC.tukeyLabel_DF <- function(tukey_results) {
  Tukey.levels <- tukey_results[["factor(dataset$accession)"]][,4]
  Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
  Tukey.labels$accession=rownames(Tukey.labels)
  rownames(Tukey.labels) <- NULL
  Tukey.labels=Tukey.labels[order(Tukey.labels$accession) , ]
  return(Tukey.labels)
}
CALC.tukeyRelation <- function(tukey_labels) {
  tukey_relation <- tukey_labels
  tukey_relation$Letters <- sapply(tukey_relation$Letters, strsplit, split = "")
  tukey_relation <- separate_rows(tukey_relation, Letters)
  tukey_relation <- tukey_relation[which(tukey_relation$Letters != ""),]
  #print(tukey_relation)
  return(tukey_relation)
}
CALC.tukeyEdgelist <- function(tukey_relation) {
  tukey_edgelist <- split(tukey_relation$accession, tukey_relation$Letters)
  return(tukey_edgelist)
}


########################################

#' @name CALC.df_SBC
#' @description Generates a dataframe of Schwarz-Bayes Criterion values from a dataframe of linear models. Each SBC value corresponds to the model in the position it occupied.
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @example CALC.df_SBC(DATA_OBJECTS.LinearRegressions_DF)

CALC.df_SBC <- function(fits_df) {
  return_df <- fits_df
  for (col in 2:ncol(fits_df)) {
    for (row in 1:nrow(fits_df)) {
      return_df[row, col] <- BIC(return_df[row, col][[1]])[[1]]
      #print(class(return_df[row, col]))
      #cat(ifelse(class(return_df[row, col]) == "list", "!", "&"))
    }
    return_df[,col] <- unlist(return_df[,col])
  }
  return(return_df)
}

#' @name CALC.df_R2
#' @description Generates a dataframe of Adjusted R^2 values from a dataframe of linear models. Each Adj. R^2 value corresponds to the model in the position it occupied.
#' @param fits_df A dataframe created by a ModelGenerator() call, containing an accession column and one or more model columns containing fitted models.
#' @example CALC.df_R2(DATA_OBJECTS.LinearRegressions_DF)

CALC.df_R2 <- function(fits_df) {
  return_df <- fits_df
  for (col in 2:ncol(fits_df)) {
    for (row in 1:nrow(fits_df)) {
      return_df[row, col] <- summary(return_df[row, col][[1]])[["adj.r.squared"]]
      #print(class(return_df[row, col]))
      #cat(ifelse(class(return_df[row, col]) == "list", "#", "@"))
    }
    return_df[,col] <- unlist(return_df[,col])
  }
  return(return_df)
}

#' @name CALC.IndependentMultivariable_Predict
#' @flag NOT USED
#' @description Generates predicted values for a model, the long way.
#' @param model_in An input linear model object with multiple predictor variables.

CALC.IndependentMultivariable_Predict <- function(model_in) {
  coeff <- model_in$coefficients
  model_data <- model_in$model
  
  coeff_names <- names(coeff)
  coeff_value <- unname(coeff)
  
  prediction_vector <- rep(coeff_value[1], nrow(model_data))
  for (term_index in c(2:length(coeff))) {
    #print(term_index)
    term_name <- coeff_names[term_index]
    term_val <- coeff_value[term_index]
    term_name_split <- str_split(term_name, ":")
    term_mult_val <- c(rep(1, nrow(model_data)))
    for (stat in term_name_split) {
      #print(stat)
      term_mult_val <- term_mult_val * model_data[[stat]]
    }
    #print("term_mult_val")
    #print(term_mult_val)
    prediction_vector <- prediction_vector + term_mult_val * coeff_value[term_index]
    print(term_mult_val * coeff_value[term_index])
    print(prediction_vector)
    #TODO: FIND OUT WHY PREDICTION VECTOR IS EMPTY!
  }
  model_out <- model_in
  model_out$model$prediction <- prediction_vector
  return(model_out)
}


# CALC.WholeDataModel_ColumnGen <- function(data_df, fits_df) {
#   models_names = names(fits_df)[-1]
# }
